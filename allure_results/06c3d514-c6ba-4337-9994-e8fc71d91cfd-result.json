{"name": "Ручка /api/v1/courier/login", "status": "broken", "statusDetails": {"message": "TypeError: unsupported callable", "trace": "func = <staticmethod(<function Functions.register_new_courier_and_return_login_password at 0x000001FD1A78A560>)>\n\n    def getfullargspec(func):\n        \"\"\"Get the names and default values of a callable object's parameters.\n    \n        A tuple of seven things is returned:\n        (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).\n        'args' is a list of the parameter names.\n        'varargs' and 'varkw' are the names of the * and ** parameters or None.\n        'defaults' is an n-tuple of the default values of the last n parameters.\n        'kwonlyargs' is a list of keyword-only parameter names.\n        'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.\n        'annotations' is a dictionary mapping parameter names to annotations.\n    \n        Notable differences from inspect.signature():\n          - the \"self\" parameter is always reported, even for bound methods\n          - wrapper chains defined by __wrapped__ *not* unwrapped automatically\n        \"\"\"\n        try:\n            # Re: `skip_bound_arg=False`\n            #\n            # There is a notable difference in behaviour between getfullargspec\n            # and Signature: the former always returns 'self' parameter for bound\n            # methods, whereas the Signature always shows the actual calling\n            # signature of the passed object.\n            #\n            # To simulate this behaviour, we \"unbind\" bound methods, to trick\n            # inspect.signature to always return their first parameter (\"self\",\n            # usually)\n    \n            # Re: `follow_wrapper_chains=False`\n            #\n            # getfullargspec() historically ignored __wrapped__ attributes,\n            # so we ensure that remains the case in 3.3+\n    \n>           sig = _signature_from_callable(func,\n                                           follow_wrapper_chains=False,\n                                           skip_bound_arg=False,\n                                           sigcls=Signature,\n                                           eval_str=False)\n\nC:\\Users\\79527\\AppData\\Local\\Programs\\Python\\Python310\\lib\\inspect.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nobj = <staticmethod(<function Functions.register_new_courier_and_return_login_password at 0x000001FD1A78A560>)>\n\n    def _signature_from_callable(obj, *,\n                                 follow_wrapper_chains=True,\n                                 skip_bound_arg=True,\n                                 globals=None,\n                                 locals=None,\n                                 eval_str=False,\n                                 sigcls):\n    \n        \"\"\"Private helper function to get signature for arbitrary\n        callable objects.\n        \"\"\"\n    \n        _get_signature_of = functools.partial(_signature_from_callable,\n                                    follow_wrapper_chains=follow_wrapper_chains,\n                                    skip_bound_arg=skip_bound_arg,\n                                    globals=globals,\n                                    locals=locals,\n                                    sigcls=sigcls,\n                                    eval_str=eval_str)\n    \n        if not callable(obj):\n            raise TypeError('{!r} is not a callable object'.format(obj))\n    \n        if isinstance(obj, types.MethodType):\n            # In this case we skip the first parameter of the underlying\n            # function (usually `self` or `cls`).\n            sig = _get_signature_of(obj.__func__)\n    \n            if skip_bound_arg:\n                return _signature_bound_method(sig)\n            else:\n                return sig\n    \n        # Was this function wrapped by a decorator?\n        if follow_wrapper_chains:\n            obj = unwrap(obj, stop=(lambda f: hasattr(f, \"__signature__\")))\n            if isinstance(obj, types.MethodType):\n                # If the unwrapped object is a *method*, we might want to\n                # skip its first parameter (self).\n                # See test_signature_wrapped_bound_method for details.\n                return _get_signature_of(obj)\n    \n        try:\n            sig = obj.__signature__\n        except AttributeError:\n            pass\n        else:\n            if sig is not None:\n                if not isinstance(sig, Signature):\n                    raise TypeError(\n                        'unexpected object {!r} in __signature__ '\n                        'attribute'.format(sig))\n                return sig\n    \n        try:\n            partialmethod = obj._partialmethod\n        except AttributeError:\n            pass\n        else:\n            if isinstance(partialmethod, functools.partialmethod):\n                # Unbound partialmethod (see functools.partialmethod)\n                # This means, that we need to calculate the signature\n                # as if it's a regular partial object, but taking into\n                # account that the first positional argument\n                # (usually `self`, or `cls`) will not be passed\n                # automatically (as for boundmethods)\n    \n                wrapped_sig = _get_signature_of(partialmethod.func)\n    \n                sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))\n                first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]\n                if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:\n                    # First argument of the wrapped callable is `*args`, as in\n                    # `partialmethod(lambda *args)`.\n                    return sig\n                else:\n                    sig_params = tuple(sig.parameters.values())\n                    assert (not sig_params or\n                            first_wrapped_param is not sig_params[0])\n                    new_params = (first_wrapped_param,) + sig_params\n                    return sig.replace(parameters=new_params)\n    \n        if isfunction(obj) or _signature_is_functionlike(obj):\n            # If it's a pure Python function, or an object that is duck type\n            # of a Python function (Cython functions, for instance), then:\n            return _signature_from_function(sigcls, obj,\n                                            skip_bound_arg=skip_bound_arg,\n                                            globals=globals, locals=locals, eval_str=eval_str)\n    \n        if _signature_is_builtin(obj):\n>           return _signature_from_builtin(sigcls, obj,\n                                           skip_bound_arg=skip_bound_arg)\n\nC:\\Users\\79527\\AppData\\Local\\Programs\\Python\\Python310\\lib\\inspect.py:2461: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <class 'inspect.Signature'>, func = <staticmethod(<function Functions.register_new_courier_and_return_login_password at 0x000001FD1A78A560>)>, skip_bound_arg = False\n\n    def _signature_from_builtin(cls, func, skip_bound_arg=True):\n        \"\"\"Private helper function to get signature for\n        builtin callables.\n        \"\"\"\n    \n        if not _signature_is_builtin(func):\n            raise TypeError(\"{!r} is not a Python builtin \"\n                            \"function\".format(func))\n    \n        s = getattr(func, \"__text_signature__\", None)\n        if not s:\n>           raise ValueError(\"no signature found for builtin {!r}\".format(func))\nE           ValueError: no signature found for builtin <staticmethod(<function Functions.register_new_courier_and_return_login_password at 0x000001FD1A78A560>)>\n\nC:\\Users\\79527\\AppData\\Local\\Programs\\Python\\Python310\\lib\\inspect.py:2271: ValueError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_api.tests.test_login_courier.TestLoginCourier object at 0x000001FD1A7D3190>\n\n    @allure.title(\"Ручка /api/v1/courier/login\")\n    @allure.description(\"Создаём нового курьера, затем логинимся с неправильным логином, ожадаем ошибку 404 и сообщение 'Учетная запись не найдена'\")\n    def test_login_courier_wrong_login(self):\n    \n>       login_pass = functions.Functions.register_new_courier_and_return_login_password()\n\ntest_api\\tests\\test_login_courier.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\79527\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\allure_commons\\utils.py:231: in func_parameters\n    arg_spec = inspect.getfullargspec(func)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfunc = <staticmethod(<function Functions.register_new_courier_and_return_login_password at 0x000001FD1A78A560>)>\n\n    def getfullargspec(func):\n        \"\"\"Get the names and default values of a callable object's parameters.\n    \n        A tuple of seven things is returned:\n        (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).\n        'args' is a list of the parameter names.\n        'varargs' and 'varkw' are the names of the * and ** parameters or None.\n        'defaults' is an n-tuple of the default values of the last n parameters.\n        'kwonlyargs' is a list of keyword-only parameter names.\n        'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.\n        'annotations' is a dictionary mapping parameter names to annotations.\n    \n        Notable differences from inspect.signature():\n          - the \"self\" parameter is always reported, even for bound methods\n          - wrapper chains defined by __wrapped__ *not* unwrapped automatically\n        \"\"\"\n        try:\n            # Re: `skip_bound_arg=False`\n            #\n            # There is a notable difference in behaviour between getfullargspec\n            # and Signature: the former always returns 'self' parameter for bound\n            # methods, whereas the Signature always shows the actual calling\n            # signature of the passed object.\n            #\n            # To simulate this behaviour, we \"unbind\" bound methods, to trick\n            # inspect.signature to always return their first parameter (\"self\",\n            # usually)\n    \n            # Re: `follow_wrapper_chains=False`\n            #\n            # getfullargspec() historically ignored __wrapped__ attributes,\n            # so we ensure that remains the case in 3.3+\n    \n            sig = _signature_from_callable(func,\n                                           follow_wrapper_chains=False,\n                                           skip_bound_arg=False,\n                                           sigcls=Signature,\n                                           eval_str=False)\n        except Exception as ex:\n            # Most of the times 'signature' will raise ValueError.\n            # But, it can also raise AttributeError, and, maybe something\n            # else. So to be fully backwards compatible, we catch all\n            # possible exceptions here, and reraise a TypeError.\n>           raise TypeError('unsupported callable') from ex\nE           TypeError: unsupported callable\n\nC:\\Users\\79527\\AppData\\Local\\Programs\\Python\\Python310\\lib\\inspect.py:1295: TypeError"}, "description": "Создаём нового курьера, затем логинимся с неправильным логином, ожадаем ошибку 404 и сообщение 'Учетная запись не найдена'", "start": 1710612253009, "stop": 1710612253009, "uuid": "924728d4-5f03-4159-8798-ec190dcc868a", "historyId": "7674ec18c973a31a591397398ab64cf7", "testCaseId": "7674ec18c973a31a591397398ab64cf7", "fullName": "test_api.tests.test_login_courier.TestLoginCourier#test_login_courier_wrong_login", "labels": [{"name": "parentSuite", "value": "test_api.tests"}, {"name": "suite", "value": "test_login_courier"}, {"name": "subSuite", "value": "TestLoginCourier"}, {"name": "host", "value": "LAPTOP-KS9V29SF"}, {"name": "thread", "value": "22020-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_api.tests.test_login_courier"}]}